---
layout: post
title:  "缓存理解要点"
date:   2023-12-10 09:00:00 +0800
categories: arch chinese
---

## 概念部分

### 1. 什么是组相连、全相连、直接相连

### 2. 组相连中 Way、Set、Offset 的含义

### 3. 缓存为什么以 CacheBlock (Cacheline) 为单位进行管理，L1/L2/L3 是否能用不同 Size 的 CacheBlock

### 4. 维护 Cache Coherence 的两种策略： Directory、Snoop

### 5. 非阻塞的缓存一定中“非阻塞”的含义，它一直是非阻塞的嘛？

### 6. 缓存包含关系 Inclusive、Non-inclusive、Exclusive 的含义（与各自优势）

### 7. 预取算法、替换算法在缓存中发挥哪些作用？

## 总线部分
（括号中为可参考的手册页数，手册版本为 TileLink SPEC 1.8.1）

### 1. ABCDE 各条通道的方向与优先级，它们分别用来传递什么信息

A通道和D通道是两个基本通道。
- A通道：从master到slave，发送对指定地址范围进行操作的请求，访问或缓存数据。
- D通道：从slave到master，向原始请求者发送数据响应或确认消息。

TL-C通道引入了B、C、E三个通道。
- B通道：从slave到master，发送请求，请求在一个被master缓存的地址上执行操作，访问或回写缓存的数据。
- C通道：从master到slave，发送数据或确认信息以响应请求。
- E通道：从master到slave，从原始请求者发送缓存块传输的最终确认，用于序列化。

消息跨通道的优先级依次为A < B < C < D < E。

### 2. 各个总线 Opcode 的语义

![TileLink op](https://github.com/yu-yake2002/yu-yake2002.github.io/raw/main/pictures/tilelink-op.png)

### 3. 缓存块的状态有几种，它们是怎么发生状态转移的（P61-P64）

- Nothing：没有缓存数据副本，没有读写权限。
- Trunk：在Tip和Root之间的路径上拥有缓存副本的节点。此副本的数据可能不是最新的，因此不具有其副本的读写权限。
- Tip：包含最新的数据。
  - Tip with no Branches：具有读写权限。可能有脏数据。
  - Tip with Branches：由于上面还有branch，所以只有读权限。可能有脏数据。如果想要写权限，就要把上面的branch清掉。
- Branch：在Tip结点之上，具有只读的副本，不具有脏数据。

![Coherence tree](https://github.com/yu-yake2002/yu-yake2002.github.io/raw/main/pictures/tilelink-tree.png)

### 4. 为什么请求之间会有“打断”的问题

保证数据的正确性，且避免死锁。

#### Probe 打断 Acquire 的重要性（P69）

当Slave收到ProbeAck之后才能向主端发送Grant。

![Probe and Acquire](https://github.com/yu-yake2002/yu-yake2002.github.io/raw/main/pictures/Probe-Acquire.png)

1. 主代理A先发送Acquire，但由于网络延迟，后到达从代理。
2. 主代理B后发送Acquire，但先到达从代理，被序列化在A的前面。
3. 从代理向A发送Probe，Slave的Grant必须包含最新数据，所以Probe的优先级要高于Acquire。即使A还在等待Grant，A也必须先处理Probe，以避免死锁。
4. 从代理接收到A的ProbeAck后，向B发送Grant。
5. 从代理接收到A的Acquire，但由于正等待B的GrantAck，所以现在还不能处理这个请求。
6. 一旦接收到B的GrantAck，A的事务就可以正常处理了。
7. 从代理向B发送Probe，但这个操作被在上一个Grant之后。
8. 从代理向A发送合适类型的Grant(包括数据副本)，说明A在Acquire后被Probe过。

#### Release 请求打断 Probe 的重要性（P69）

如果Master在一个块上有一个未完成的Release事务，它就不能用ProbeAcks响应此块上传入的探测请求，直到它从Slave收到一个ReleaseAck，确认回写完成。

![Probe and Acquire](https://github.com/yu-yake2002/yu-yake2002.github.io/raw/main/pictures/Release-Probe.png)

1. 主代理A向从代理发送Acquire。
2. 与此同时，主代理B通过Release主动剔除相同的数据缓存块。
3. 从代理向B发送Probe。
4. 从代理等待每个发送出的Probe，但可以处理主动发起的Release。从代理发送ReleaseAck确认主动写回的操作完成。
5. B在接收到写回确认前不处理Probe。
6. 在从代理接收到B的ProbeAck后，A的事务就可以正常执行了。

### 6. 为什么 Grant 和 Release 后续都需要分别跟一个 GrantAck 和 ReleaseAck（P69）

假设将消息点到点、有序地传递到特定的代理，那么Slave只需将Grant消息发送到原始的Master就足够了。
Slave可以处理块上的后续事务。
对同一Master的后续Probe和Grant将按顺序到达。
由于不能保证这种排序，因此我们转而依赖GrantAck消息来允许从Slave序列化这两个事务。

ReleaseAck同理。

## CPL2 部分
参考代码为 CPL2 的 master 分支 https://github.com/OpenXiangShan/CoupledL2

### 1. 缓存总体框架

### 2. 请求的处理流程
  a. 收到 L1 Acquire，且命中
  b. 收到 L1 Acquire，且缺失，需要从 L3 获取
  c. b 的基础上 + 需要替换
  d. 收到 L3 Probe， 且需要去 Probe L1

### 3. ReqArb / MainPipe 包含几个流水级，分别完成什么任务

### 4. Directory 目录项包含哪些内容

### 5. 状态机的逻辑
- s_ 表示要调度的请求，w_ 表示要等待的应答
- 设置逻辑：在 MainPipe 最后的 alloc_state 部分
- 控制子请求的逻辑：MSHR 中

### 6. 流水线入口阻塞逻辑（ReqArb 里的 BlockA/B/C）
- *如何支持同 set 请求的并发处理（新请求进入主流水线的条件，什么时候需要阻塞新请求）

### 7. GrantBuffer 的作用
- 向上层返回响应（D 通道，一个缓存块包含两个总线上的数据 beat）
- 接收 GrantAck（E 通道）
- 阻塞流水线入口（反压控制）

### 8. RefillBuffer 和 ReleaseBuffer 的作用

### 9. 如何实现高优先级请求对低优先级请求的嵌套

### 10. Cache 别名问题是什么，怎么解决的

### 11. *预取请求的处理

## HuanCun 部分